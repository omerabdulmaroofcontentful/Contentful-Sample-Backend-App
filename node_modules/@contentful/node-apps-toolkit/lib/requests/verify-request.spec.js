"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const verify_request_1 = require("./verify-request");
const typings_1 = require("./typings");
const sign_request_1 = require("./sign-request");
const exceptions_1 = require("./exceptions");
const makeIncomingRequest = ({ path = '/api/v1/resources/1', method = 'GET', headers, body, }, now = Date.now()) => {
    const request = {
        path,
        method,
        headers,
        body,
    };
    const signedHeaders = sign_request_1.signRequest(VALID_SECRET, request, now);
    return {
        ...request,
        headers: {
            ...request.headers,
            ...signedHeaders,
        },
    };
};
const VALID_SECRET = new Array(64).fill('a').join('');
describe('isVerifiedRequest', () => {
    it('verifies a verified request', () => {
        const now = Date.now();
        const incomingRequest = makeIncomingRequest({
            headers: {
                Authorization: 'Bearer TOKEN',
            },
        }, now);
        assert(verify_request_1.verifyRequest(VALID_SECRET, incomingRequest, 0));
    });
    describe('with time to live', () => {
        it('throws if request is too old', () => {
            const oneMinuteAgo = Date.now() - 1000 * 60;
            const incomingRequest = makeIncomingRequest({
                headers: {
                    Authorization: 'Bearer TOKEN',
                },
            }, oneMinuteAgo);
            assert.throws(() => verify_request_1.verifyRequest(VALID_SECRET, incomingRequest, 1), exceptions_1.ExpiredRequestException);
        });
        it('does not check if ttl is 0', () => {
            const oneMinuteAgo = Date.now() - 1000 * 60;
            const incomingRequest = makeIncomingRequest({
                headers: {
                    Authorization: 'Bearer TOKEN',
                },
            }, oneMinuteAgo);
            assert.doesNotThrow(() => verify_request_1.verifyRequest(VALID_SECRET, incomingRequest, 0), exceptions_1.ExpiredRequestException);
        });
    });
    describe('with contentful headers', () => {
        it('verifies correctly with keys with different casing', () => {
            const incomingRequest = makeIncomingRequest({});
            // mess with casing
            incomingRequest.headers[typings_1.ContentfulHeader.Signature.toUpperCase()] =
                incomingRequest.headers[typings_1.ContentfulHeader.Signature];
            incomingRequest.headers[typings_1.ContentfulHeader.SignedHeaders.toUpperCase()] =
                incomingRequest.headers[typings_1.ContentfulHeader.SignedHeaders];
            incomingRequest.headers[typings_1.ContentfulHeader.Timestamp.toUpperCase()] =
                incomingRequest.headers[typings_1.ContentfulHeader.Timestamp];
            // remove correctly cased ones
            delete incomingRequest.headers[typings_1.ContentfulHeader.Signature];
            delete incomingRequest.headers[typings_1.ContentfulHeader.SignedHeaders];
            delete incomingRequest.headers[typings_1.ContentfulHeader.Timestamp];
            assert(verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
        it('verifies correctly with keys with whitespace', () => {
            const incomingRequest = makeIncomingRequest({});
            // mess with spacing
            incomingRequest.headers[`${typings_1.ContentfulHeader.Signature}      `] =
                incomingRequest.headers[typings_1.ContentfulHeader.Signature];
            incomingRequest.headers[`   ${typings_1.ContentfulHeader.SignedHeaders}   `] =
                incomingRequest.headers[typings_1.ContentfulHeader.SignedHeaders];
            incomingRequest.headers[`      ${typings_1.ContentfulHeader.Timestamp}`] =
                incomingRequest.headers[typings_1.ContentfulHeader.Timestamp];
            // remove correctly spaced ones
            delete incomingRequest.headers[typings_1.ContentfulHeader.Signature];
            delete incomingRequest.headers[typings_1.ContentfulHeader.SignedHeaders];
            delete incomingRequest.headers[typings_1.ContentfulHeader.Timestamp];
            assert(verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
        it('throws when missing signature', () => {
            const incomingRequest = makeIncomingRequest({});
            delete incomingRequest.headers[typings_1.ContentfulHeader.Signature];
            assert.throws(() => verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
        it('throws when missing timestamp', () => {
            const incomingRequest = makeIncomingRequest({});
            delete incomingRequest.headers[typings_1.ContentfulHeader.Timestamp];
            assert.throws(() => verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
        it('throws when missing signed headers', () => {
            const incomingRequest = makeIncomingRequest({
                headers: { Authorization: 'Bearer TOKEN' },
            });
            delete incomingRequest.headers[typings_1.ContentfulHeader.SignedHeaders];
            assert.throws(() => verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
    });
    describe('with other headers', () => {
        it('verifies with keys with different casing', () => {
            const authorization = 'Bearer TOKEN';
            const cacheControl = 'no-cache';
            const incomingRequest = makeIncomingRequest({
                headers: {
                    Authorization: authorization,
                    'Cache-Control': cacheControl,
                },
            });
            // mess with casing
            incomingRequest.headers = {
                authORizAtioN: authorization,
                'CACHE-control': cacheControl,
                ...incomingRequest.headers,
            };
            // remove correctly cased ones
            delete incomingRequest.headers['Authorization'];
            delete incomingRequest.headers['Cache-Control'];
            assert(verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
        it('verifies with keys with whitespace', () => {
            const authorization = 'Bearer TOKEN';
            const cacheControl = 'no-cache';
            const incomingRequest = makeIncomingRequest({
                headers: {
                    Authorization: authorization,
                    'Cache-Control': cacheControl,
                },
            });
            // mess with spacing
            incomingRequest.headers = {
                'Authorization      ': authorization,
                '   Cache-Control  ': cacheControl,
                ...incomingRequest.headers,
            };
            // remove correctly spaced ones
            delete incomingRequest.headers['Authorization'];
            delete incomingRequest.headers['Cache-Control'];
            assert(verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
        it('verifies with different headers, if they are not signed', () => {
            const authorization = 'Bearer TOKEN';
            const cacheControl = 'no-cache';
            const incomingRequest = makeIncomingRequest({
                headers: {
                    Authorization: authorization,
                    'Cache-Control': cacheControl,
                },
            });
            incomingRequest.headers['Content-Type'] = 'application/json';
            assert(verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
        it('does not verify with different signed headers', () => {
            const authorization = 'Bearer TOKEN';
            const cacheControl = 'no-cache';
            const incomingRequest = makeIncomingRequest({
                headers: {
                    Authorization: authorization,
                    'Cache-Control': cacheControl,
                },
            });
            incomingRequest.headers['Authorization'] = 'something else';
            assert(!verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
        it("verifies with headers sorted lower than contentful's", () => {
            const incomingRequest = makeIncomingRequest({
                headers: {
                    Authorization: 'Bearer Token',
                    'z-zzzzz': 'ronf ronf',
                },
            });
            assert(verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
    });
    describe('with paths', () => {
        it('does not verify with different query params', () => {
            const path = '/api/v1';
            const pathWithQueryOne = `${path}?a=1&b=2`;
            const pathWithQueryTwo = `${path}?b=2&a=1`;
            const incomingRequest = makeIncomingRequest({ path: pathWithQueryOne });
            incomingRequest.path = pathWithQueryTwo;
            assert(!verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
    });
    describe('with method', () => {
        it('does not verify with different methods', () => {
            const incomingRequest = makeIncomingRequest({ method: 'GET' });
            incomingRequest.method = 'POST';
            assert(!verify_request_1.verifyRequest(VALID_SECRET, incomingRequest));
        });
    });
    describe('with secrets', () => {
        it('does not verify with different secrets', () => {
            const incomingRequest = makeIncomingRequest({
                headers: {
                    Authorization: 'Bearer TOKEN',
                },
            });
            const differentSecret = `q${VALID_SECRET.slice(1, VALID_SECRET.length)}`;
            assert(!verify_request_1.verifyRequest(differentSecret, incomingRequest));
        });
    });
});
//# sourceMappingURL=verify-request.spec.js.map
import { CanonicalRequest, Secret, SignedRequestHeaders, Timestamp } from './typings';
/**
 * Given a secret, a canonical request and a timestamp, generates a signature.
 * It can be used to verify canonical requests to assess authenticity of the
 * sender and integrity of the payload.
 *
 * ~~~
 * const {signRequest, ContentfulHeader} = require('@contentful/node-apps-toolkit')
 * const {pick} = require('lodash')
 * const {server} = require('./imaginary-server')
 *
 * const SECRET = process.env.SECRET
 *
 * server.post('/api/my-resources', (req, res) => {
 *   const incomingSignature = req.headers['x-contentful-signature']
 *   const incomingTimestamp = Number.parseInt(req.headers['x-contentful-timestamp'])
 *   const incomingSignedHeaders = req.headers['x-contentful-signed-headers']
 *   const now = Date.now()
 *
 *   if (!incomingSignature) {
 *     res.send(400, 'Missing signature')
 *   }
 *
 *   if (now - incomingTimestamp > 1000) {
 *     res.send(408, 'Request too old')
 *   }
 *
 *   const signedHeaders = incomingSignedHeaders.split(',')
 *
 *   const {[ContentfulHeader.Signature]: computedSignature} = signRequest(
 *     SECRET,
 *     {
 *       method: req.method,
 *       path: req.url,
 *       headers: pick(req.headers, signedHeaders),
 *       body: JSON.stringify(req.body)
 *     },
 *     incomingTimestamp
 *   )
 *
 *   if (computedSignature !== incomingSignature) {
 *      res.send(403, 'Invalid signature')
 *   }
 *
 *   // rest of the code
 * })
 *
 * ~~~
 * @category Requests
 */
export declare const signRequest: (rawSecret: Secret, rawCanonicalRequest: CanonicalRequest, rawTimestamp?: Timestamp) => SignedRequestHeaders;

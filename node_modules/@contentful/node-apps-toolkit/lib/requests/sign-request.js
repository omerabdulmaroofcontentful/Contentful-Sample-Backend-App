"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signRequest = void 0;
const crypto = require("crypto");
const typings_1 = require("./typings");
const typings_2 = require("./typings");
const utils_1 = require("./utils");
const hash = (normalizedCanonicalRequest, secret) => {
    const stringifiedHeaders = normalizedCanonicalRequest
        .headers.map(([key, value]) => `${key}:${value}`)
        .join(';');
    const stringifiedRequest = [
        normalizedCanonicalRequest.method,
        normalizedCanonicalRequest.path,
        stringifiedHeaders,
        normalizedCanonicalRequest.body,
    ].join('\n');
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(stringifiedRequest);
    return hmac.digest('hex');
};
const getSortedAndSignedHeaders = (headers, timestamp) => {
    const rawSignedHeaders = Object.keys(headers);
    if (!(typings_1.ContentfulHeader.SignedHeaders in headers)) {
        rawSignedHeaders.push(typings_1.ContentfulHeader.SignedHeaders);
    }
    if (!(typings_1.ContentfulHeader.Timestamp in headers)) {
        rawSignedHeaders.push(typings_1.ContentfulHeader.Timestamp);
    }
    const signedHeaders = rawSignedHeaders.sort(utils_1.sortHeaderKeys).join(',');
    headers[typings_1.ContentfulHeader.Timestamp] = timestamp.toString();
    headers[typings_1.ContentfulHeader.SignedHeaders] = signedHeaders;
    const sortedHeaders = Object.entries(headers).sort(([keyA], [keyB]) => utils_1.sortHeaderKeys(keyA, keyB));
    return { sortedHeaders, signedHeaders };
};
/**
 * Given a secret, a canonical request and a timestamp, generates a signature.
 * It can be used to verify canonical requests to assess authenticity of the
 * sender and integrity of the payload.
 *
 * ~~~
 * const {signRequest, ContentfulHeader} = require('@contentful/node-apps-toolkit')
 * const {pick} = require('lodash')
 * const {server} = require('./imaginary-server')
 *
 * const SECRET = process.env.SECRET
 *
 * server.post('/api/my-resources', (req, res) => {
 *   const incomingSignature = req.headers['x-contentful-signature']
 *   const incomingTimestamp = Number.parseInt(req.headers['x-contentful-timestamp'])
 *   const incomingSignedHeaders = req.headers['x-contentful-signed-headers']
 *   const now = Date.now()
 *
 *   if (!incomingSignature) {
 *     res.send(400, 'Missing signature')
 *   }
 *
 *   if (now - incomingTimestamp > 1000) {
 *     res.send(408, 'Request too old')
 *   }
 *
 *   const signedHeaders = incomingSignedHeaders.split(',')
 *
 *   const {[ContentfulHeader.Signature]: computedSignature} = signRequest(
 *     SECRET,
 *     {
 *       method: req.method,
 *       path: req.url,
 *       headers: pick(req.headers, signedHeaders),
 *       body: JSON.stringify(req.body)
 *     },
 *     incomingTimestamp
 *   )
 *
 *   if (computedSignature !== incomingSignature) {
 *      res.send(403, 'Invalid signature')
 *   }
 *
 *   // rest of the code
 * })
 *
 * ~~~
 * @category Requests
 */
exports.signRequest = (rawSecret, rawCanonicalRequest, rawTimestamp = Date.now()) => {
    var _a;
    const canonicalRequest = typings_2.CanonicalRequestValidator.check(rawCanonicalRequest);
    const timestamp = typings_2.TimestampValidator.check(rawTimestamp);
    const secret = typings_2.SecretValidator.check(rawSecret);
    const path = utils_1.getNormalizedEncodedURI(canonicalRequest.path);
    const method = canonicalRequest.method;
    const headers = canonicalRequest.headers ? utils_1.normalizeHeaders(canonicalRequest.headers) : {};
    const body = (_a = canonicalRequest.body) !== null && _a !== void 0 ? _a : '';
    const { sortedHeaders, signedHeaders } = getSortedAndSignedHeaders(headers, timestamp);
    return {
        [typings_1.ContentfulHeader.Signature]: hash({ method, headers: sortedHeaders, path, body }, secret),
        [typings_1.ContentfulHeader.SignedHeaders]: signedHeaders,
        [typings_1.ContentfulHeader.Timestamp]: timestamp.toString(),
    };
};
//# sourceMappingURL=sign-request.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const fs = require("fs");
const path = require("path");
const sinon = require("sinon");
const get_management_token_1 = require("./get-management-token");
const utils_1 = require("../utils");
const jsonwebtoken_1 = require("jsonwebtoken");
const NodeCache = require("node-cache");
const PRIVATE_KEY = fs.readFileSync(path.join(__dirname, '..', '..', 'keys', 'key.pem'), 'utf-8');
const APP_ID = 'app_id';
const SPACE_ID = 'space_id';
const ENVIRONMENT_ID = 'env_id';
const DEFAULT_OPTIONS = {
    appInstallationId: APP_ID,
    spaceId: SPACE_ID,
    environmentId: ENVIRONMENT_ID,
    reuseToken: false,
};
const noop = () => { };
describe('getManagementToken', () => {
    it('fetches a token', async () => {
        const mockToken = 'token';
        const logger = noop;
        const post = sinon.stub();
        post.resolves({ statusCode: 201, body: JSON.stringify({ token: mockToken }) });
        const httpClient = { post };
        const getManagementToken = get_management_token_1.createGetManagementToken(logger, httpClient);
        const result = await getManagementToken(PRIVATE_KEY, DEFAULT_OPTIONS);
        assert.deepStrictEqual(result, mockToken);
        assert(post.calledWith(`spaces/${SPACE_ID}/environments/${ENVIRONMENT_ID}/app_installations/${APP_ID}/access_tokens`, sinon.match({ headers: { Authorization: sinon.match.string } })));
    });
    it('caches token while valid', async () => {
        const logger = noop;
        const post = sinon.stub();
        const mockToken = jsonwebtoken_1.sign({ a: 'b' }, 'a-secret-key', {
            expiresIn: '10 minutes',
        });
        post.resolves({ statusCode: 201, body: JSON.stringify({ token: mockToken }) });
        const httpClient = { post };
        const getManagementToken = get_management_token_1.createGetManagementToken(logger, httpClient);
        const optionsWithCaching = { ...DEFAULT_OPTIONS, reuseToken: true };
        const result = await getManagementToken(PRIVATE_KEY, optionsWithCaching);
        assert.strictEqual(result, mockToken);
        const secondResult = await getManagementToken(PRIVATE_KEY, optionsWithCaching);
        assert.strictEqual(secondResult, mockToken);
        assert(post.calledOnce);
    });
    it('does not cache expired token', async () => {
        const logger = noop;
        const post = sinon.stub();
        const mockToken = jsonwebtoken_1.sign({ a: 'b' }, 'a-secret-key', {
            expiresIn: '5 minutes',
        });
        post.resolves({ statusCode: 201, body: JSON.stringify({ token: mockToken }) });
        const httpClient = { post };
        const cache = new NodeCache();
        const getManagementToken = get_management_token_1.createGetManagementToken(logger, httpClient, cache);
        const optionsWithCaching = { ...DEFAULT_OPTIONS, reuseToken: true };
        const result = await getManagementToken(PRIVATE_KEY, optionsWithCaching);
        assert.strictEqual(result, mockToken);
        // Overwrite TTL expiry to 5ms
        const cacheKey = APP_ID + ENVIRONMENT_ID + PRIVATE_KEY.slice(32, 132);
        cache.set(cacheKey, result, 0.005);
        // Sleep 10ms
        await new Promise((resolve) => {
            setTimeout(resolve, 10);
        });
        const secondResult = await getManagementToken(PRIVATE_KEY, optionsWithCaching);
        assert.strictEqual(secondResult, mockToken);
        assert(post.calledTwice);
    });
    describe('when using a keyId', () => {
        it('fetches a token', async () => {
            const mockToken = 'token';
            const logger = noop;
            const post = sinon.stub();
            post.resolves({ statusCode: 201, body: JSON.stringify({ token: mockToken }) });
            const httpClient = { post };
            const getManagementToken = get_management_token_1.createGetManagementToken(logger, httpClient);
            const result = await getManagementToken(PRIVATE_KEY, { ...DEFAULT_OPTIONS, keyId: 'keyId' });
            assert.deepStrictEqual(result, mockToken);
            assert(post.calledWith(`spaces/${SPACE_ID}/environments/${ENVIRONMENT_ID}/app_installations/${APP_ID}/access_tokens`, sinon.match({ headers: { Authorization: sinon.match.string } })));
        });
    });
    describe('when private key is incorrect', () => {
        it('throws if missing', async () => {
            await assert.rejects(async () => {
                // @ts-ignore Testing javascript code
                await get_management_token_1.getManagementToken(undefined, DEFAULT_OPTIONS);
            });
        });
        it('throws if generated with wrong algorithm', async () => {
            await assert.rejects(async () => {
                await get_management_token_1.getManagementToken('not_a_private_key', DEFAULT_OPTIONS);
            });
        });
    });
    describe('when having API problems', () => {
        it(`throws when API returns an error`, async () => {
            const logger = noop;
            const post = sinon.stub().rejects(new utils_1.HttpError({ statusCode: 500 }));
            const httpClient = { post };
            const getManagementToken = get_management_token_1.createGetManagementToken(logger, httpClient);
            await assert.rejects(async () => {
                await getManagementToken(PRIVATE_KEY, DEFAULT_OPTIONS);
            }, utils_1.HttpError);
        });
    });
});
//# sourceMappingURL=get-management-token.spec.js.map